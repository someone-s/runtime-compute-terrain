#pragma kernel UpdateTrack

#define EPSILON (0.00000001)
#define DIVIDE9 (0.11111111)

#define MAX_SLICE_SIZE 1024

ByteAddressBuffer sourceVertices;
RWByteAddressBuffer destVertices;

uint sliceSize; // Number of points per slice
uint sliceCount; // Number of slices
uint slicePerThread; // if sliceCount is 80, slicePerThread is 2 ceil(80 / 64)

int stride;
int positionOffset;
int normalOffset;

float3 Rotate(float3 source, float4 rotation) {
    return 2.0 * dot(rotation.xyz, source) * rotation.xyz
         + (rotation.w * rotation.w - dot(rotation.xyz, rotation.xyz)) * source
         + 2.0 * rotation.w * cross(rotation.xyz, source);
}

struct Point {
    float3 position;
    float4 rotation;
};

StructuredBuffer<Point> points;
uint pointCount;

// this oeprate per section
[numthreads(MAX_SLICE_SIZE, 1, 1)]
void UpdateTrack(uint3 id : SV_DispatchThreadID) {

    uint sliceIndex = id.x;

    float3 position = points[min(sliceIndex, pointCount - 1)].position;
    float4 rotation = points[min(sliceIndex, pointCount - 1)].rotation;
 
    for (uint i = 0; i < sliceSize; i++) {
        uint locationStart = (sliceIndex * sliceSize + i) * stride;

        uint posLocation     = locationStart + positionOffset;
        float3 sourcePos     = asfloat(sourceVertices.Load3(posLocation));
        float3 rotatedPos    = Rotate(sourcePos, rotation);
        float3 translatedPos = rotatedPos + position;
        destVertices.Store3(posLocation, asuint(translatedPos));

        uint normLocation  = locationStart + normalOffset;
        float3 sourceNorm  = asfloat(sourceVertices.Load3(normLocation));
        float3 rotatedNorm = Rotate(sourceNorm, rotation);
        destVertices.Store3(normLocation, asuint(rotatedNorm));
    }
}

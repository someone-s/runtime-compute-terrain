#pragma kernel ResetBuffers
#pragma kernel RestoreBuffers
#pragma kernel ExportBuffers

#define FLOAT_SIZE_IN_BYTES 4

uint size; // i.e. 1000
uint meshSection; // if size is 1000, meshSection is 126 ceil((1000 * 2 + 1) / 32)

RWByteAddressBuffer vertices;
int stride;
int positionOffset;
int normalOffset;
int baseOffset;
int modifyOffset;

uint CalculateLogicalIndex(uint x, uint y) {
    return y * (size + 1) + x;
}

uint CalculateVertexIndex(uint x, uint y) {
    return (y * (size + 1) + x) * stride + positionOffset;
}
void StoreVertexY(uint x, uint y, float value) {
    vertices.Store(CalculateVertexIndex(x, y) + FLOAT_SIZE_IN_BYTES, asuint(value));
}

uint CalculateModifyIndex(uint x, uint y) {
    return (y * (size + 1) + x) * stride + modifyOffset;
}
void StoreModify(uint x, uint y, float mandate, float minimum, float maximum, uint mask) {

    uint4 bits;
    bits.x = mask;
    bits.y = asuint(mandate);
    bits.z = asuint(minimum);
    bits.w = asuint(maximum);

    vertices.Store4(CalculateModifyIndex(x, y), bits);
}

uint CalculateBaseIndex(uint x, uint y) {
    return (y * (size + 1) + x) * stride + baseOffset;
}
float LoadBase(uint x, uint y) {
        return asfloat(vertices.Load(CalculateBaseIndex(x, y)));
}
void StoreBase(uint x, uint y, float value) {
        vertices.Store(CalculateBaseIndex(x, y), asuint(value));
}


// this oeprate per vertex
[numthreads(32, 32, 1)]
void ResetBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * meshSection; x < (id.x + 1) * meshSection && x < (size * 2) + 1; x++) {
    
            for (uint y = id.y * meshSection; y <  (id.y + 1) * meshSection && y < (size * 2) + 1; y++) {
    
                StoreModify(x, y, 0.0, 0.0, 0.0, 0);
                StoreBase(x, y, 0.0);
            }
        }
    }
}


struct Export {
    float height;
};
RWStructuredBuffer<Export> exports;

// this oeprate per vertex
[numthreads(32, 32, 1)]
void RestoreBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * meshSection; x < (id.x + 1) * meshSection && x < (size * 2) + 1; x++) {
    
            for (uint y = id.y * meshSection; y <  (id.y + 1) * meshSection && y < (size * 2) + 1; y++) {
                
                uint index = CalculateLogicalIndex(x, y);
                StoreVertexY(x, y, exports[index].height);
                StoreBase(x, y, exports[index].height);
            }
        }
    }
}

[numthreads(32, 32, 1)]
void ExportBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * meshSection; x < (id.x + 1) * meshSection && x < (size * 2) + 1; x++) {
    
            for (uint y = id.y * meshSection; y <  (id.y + 1) * meshSection && y < (size * 2) + 1; y++) {
                
                uint index = CalculateLogicalIndex(x, y);
                exports[index].height = LoadBase(x, y);
            }
        }
    }
}
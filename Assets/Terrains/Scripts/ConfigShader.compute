#pragma kernel ResetBuffers
#pragma kernel RestoreBuffers
#pragma kernel ExportBuffers

#define FLOAT_SIZE_IN_BYTES 4

uint _Size; // i.e. 1000
uint _MeshSection; // if _Size is 1000, _MeshSection is 126 ceil((1000 * 2 + 1) / 32)

RWByteAddressBuffer _Vertices;
int _Stride;
int _PositionOffset;
int _BaseOffset;
int _ModifyOffset;

uint CalculateLogicalIndex(uint x, uint y) {
    return y * (_Size + 1) + x;
}

uint CalculateVertexIndex(uint x, uint y) {
    return (y * (_Size + 1) + x) * _Stride + _PositionOffset;
}
void StoreVertexY(uint x, uint y, float value) {
    _Vertices.Store(CalculateVertexIndex(x, y) + FLOAT_SIZE_IN_BYTES, asuint(value));
}

uint CalculateModifyIndex(uint x, uint y) {
    return (y * (_Size + 1) + x) * _Stride + _ModifyOffset;
}
void StoreModify(uint x, uint y, float mandate, float minimum, float maximum, uint mask) {

    uint4 bits;
    bits.x = mask;
    bits.y = asuint(mandate);
    bits.z = asuint(minimum);
    bits.w = asuint(maximum);

    _Vertices.Store4(CalculateModifyIndex(x, y), bits);
}

uint CalculateBaseIndex(uint x, uint y) {
    return (y * (_Size + 1) + x) * _Stride + _BaseOffset;
}
float LoadBase(uint x, uint y) {
        return asfloat(_Vertices.Load(CalculateBaseIndex(x, y)));
}
void StoreBase(uint x, uint y, float value) {
        _Vertices.Store(CalculateBaseIndex(x, y), asuint(value));
}


// this oeprate per vertex
[numthreads(32, 32, 1)]
void ResetBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
    
                StoreModify(x, y, 0.0, 0.0, 0.0, 0);
                StoreBase(x, y, 0.0);
            }
        }
    }
}


struct Export {
    float height;
};
RWStructuredBuffer<Export> _Exports;

// this oeprate per vertex
[numthreads(32, 32, 1)]
void RestoreBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
                
                uint index = CalculateLogicalIndex(x, y);
                StoreVertexY(x, y, _Exports[index].height);
                StoreBase(x, y, _Exports[index].height);
            }
        }
    }
}

[numthreads(32, 32, 1)]
void ExportBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
                
                uint index = CalculateLogicalIndex(x, y);
                _Exports[index].height = LoadBase(x, y);
            }
        }
    }
}
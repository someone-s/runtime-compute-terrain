#pragma kernel ApplyModifiers DEFINE_APPLY
#pragma kernel ModifyMesh DEFINE_OPERATION

#define MANDATE_BIT 1
#define MINIMUM_BIT 2
#define MAXIMUM_BIT 4
#define EPSILON 0.00000001
#define DIVIDE9 0.11111111
#define DIVIDE25 0.04
#define FLOAT_SIZE_IN_BYTES 4

struct Modify {
    uint mask;
    float mandate;
    float minimum;
    float maximum;
};

RWByteAddressBuffer _VerticesTL;

RWByteAddressBuffer _VerticesTR;

RWByteAddressBuffer _VerticesBL;

RWByteAddressBuffer _VerticesBR;

int _Stride;
int _PositionOffset;
int _NormalOffset;
int _BaseOffset;
int _ModifyOffset;

float _Area;
uint _Size; // i.e. 1000
uint _MeshSection; // if _Size is 1000, _MeshSection is 126 ceil((1000 * 2 + 1) / 32)

uint CalculateVertexIndex(uint x, uint y) {
    return (y * (_Size + 1) + x) * _Stride + _PositionOffset;
}
float3 LoadVertex(uint x, uint y) {
    if (x > _Size && y > _Size) {
        float3 value = asfloat(_VerticesTR.Load3(CalculateVertexIndex(x - _Size, y - _Size)));
        value.x += _Area;
        value.z += _Area;
        return value;
    }
    else if (x > _Size) {
        float3 value = asfloat(_VerticesBR.Load3(CalculateVertexIndex(x - _Size, y)));
        value.x += _Area;
        return value;
    }
    else if (y > _Size) {
        float3 value = asfloat(_VerticesTL.Load3(CalculateVertexIndex(x, y - _Size)));
        value.z += _Area;
        return value;
    }
    else {
        float3 value = asfloat(_VerticesBL.Load3(CalculateVertexIndex(x, y)));
        return value;
    }
}
void StoreVertex(uint x, uint y, float3 value) {
    if (x >= _Size && y >= _Size) {
        float3 valueCopy = value;
        valueCopy.x -= _Area;
        valueCopy.z -= _Area;
        _VerticesTR.Store3(CalculateVertexIndex(x - _Size, y - _Size), asuint(valueCopy));
    }

    if (x >= _Size && y <= _Size) {
        float3 valueCopy = value;
        valueCopy.x -= _Area;
        _VerticesBR.Store3(CalculateVertexIndex(x - _Size, y), asuint(valueCopy));
    }

    if (x <= _Size && y >= _Size) {
        float3 valueCopy = value;
        valueCopy.z -= _Area;
        _VerticesTL.Store3(CalculateVertexIndex(x, y - _Size), asuint(valueCopy));
    }

    if (x <= _Size && y <= _Size) {
        float3 valueCopy = value;
        _VerticesBL.Store3(CalculateVertexIndex(x, y), asuint(valueCopy));
    }
}
void StoreVertexY(uint x, uint y, float value) {
    if (x >= _Size && y >= _Size) 
        _VerticesTR.Store(CalculateVertexIndex(x - _Size, y - _Size) + FLOAT_SIZE_IN_BYTES, asuint(value));

    if (x >= _Size && y <= _Size) 
        _VerticesBR.Store(CalculateVertexIndex(x - _Size, y) + FLOAT_SIZE_IN_BYTES, asuint(value));

    if (x <= _Size && y >= _Size) 
        _VerticesTL.Store(CalculateVertexIndex(x, y - _Size) + FLOAT_SIZE_IN_BYTES, asuint(value));

    if (x <= _Size && y <= _Size) 
        _VerticesBL.Store(CalculateVertexIndex(x, y) + FLOAT_SIZE_IN_BYTES, asuint(value));
}

uint CalculateNormalIndex(uint x, uint y) {
    return (y * (_Size + 1) + x) * _Stride + _NormalOffset;
}
void StoreNormal(uint x, uint y, float3 value) {
    if (x >= _Size && y >= _Size)
        _VerticesTR.Store3(CalculateNormalIndex(x - _Size, y - _Size), asuint(value));

    if (x >= _Size && y <= _Size)
        _VerticesBR.Store3(CalculateNormalIndex(x - _Size, y), asuint(value));

    if (x <= _Size && y >= _Size)
        _VerticesTL.Store3(CalculateNormalIndex(x, y - _Size), asuint(value));

    if (x <= _Size && y <= _Size)
        _VerticesBL.Store3(CalculateNormalIndex(x, y), asuint(value));
}

uint CalculateModifyIndex(uint x, uint y) {
    return (y * (_Size + 1) + x) * _Stride + _ModifyOffset;
}
Modify LoadModify(uint x, uint y) {
    uint4 bits;

    if (x > _Size && y > _Size)
        bits = _VerticesTR.Load4(CalculateModifyIndex(x - _Size, y - _Size));
    else if (x > _Size) 
        bits = _VerticesBR.Load4(CalculateModifyIndex(x - _Size, y       ));
    else if (y > _Size) 
        bits = _VerticesTL.Load4(CalculateModifyIndex(x,        y - _Size));
    else 
        bits = _VerticesBL.Load4(CalculateModifyIndex(x,        y       ));

    Modify modify;
    modify.mask = bits.x;

    float4 vals = asfloat(bits);
    modify.mandate = vals.y;
    modify.minimum = vals.z;
    modify.maximum = vals.w;

    return modify;
}
void StoreModify(uint x, uint y, float mandate, float minimum, float maximum, uint mask) {

    uint4 bits;
    bits.x = mask;
    bits.y = asuint(mandate);
    bits.z = asuint(minimum);
    bits.w = asuint(maximum);

    if (x >= _Size && y >= _Size)
        _VerticesTR.Store4(CalculateModifyIndex(x - _Size, y - _Size), bits);

    if (x >= _Size && y <= _Size)
        _VerticesBR.Store4(CalculateModifyIndex(x - _Size, y       ), bits);

    if (x <= _Size && y >= _Size) 
        _VerticesTL.Store4(CalculateModifyIndex(x       , y - _Size), bits);

    if (x <= _Size && y <= _Size) 
        _VerticesBL.Store4(CalculateModifyIndex(x       , y       ), bits);
}

uint CalculateBaseIndex(uint x, uint y) {
    return (y * (_Size + 1) + x) * _Stride + _BaseOffset;
}
float LoadBase(uint x, uint y) {
    if (x > _Size && y > _Size)
        return asfloat(_VerticesTR.Load(CalculateBaseIndex(x - _Size, y - _Size)));
    else if (x > _Size) 
        return asfloat(_VerticesBR.Load(CalculateBaseIndex(x - _Size, y       )));
    else if (y > _Size) 
        return asfloat(_VerticesTL.Load(CalculateBaseIndex(x,        y - _Size)));
    else 
        return asfloat(_VerticesBL.Load(CalculateBaseIndex(x,        y       )));
}
void StoreBase(uint x, uint y, float value) {
    if (x >= _Size && y >= _Size)
        _VerticesTR.Store(CalculateBaseIndex(x - _Size, y - _Size), asuint(value));

    if (x >= _Size && y <= _Size)
        _VerticesBR.Store(CalculateBaseIndex(x - _Size, y       ), asuint(value));

    if (x <= _Size && y >= _Size) 
        _VerticesTL.Store(CalculateBaseIndex(x       , y - _Size), asuint(value));

    if (x <= _Size && y <= _Size) 
        _VerticesBL.Store(CalculateBaseIndex(x       , y       ), asuint(value));
}


void ApplyNormals(uint3 id) {

    // Recalculate Normal
    {
        for (uint x = id.x * _MeshSection > 0 ? id.x * _MeshSection : 1; x < (id.x + 1) * _MeshSection && x < (_Size * 2); x++) {
    
            for (uint y = id.y * _MeshSection ? id.y * _MeshSection : 1; y <  (id.y + 1) * _MeshSection && y < (_Size * 2); y++) {
    
                float3 vertex = LoadVertex(x, y);
    
                float3 selfPt   = LoadVertex(x, y);
                float3 leftDir  = normalize(selfPt - LoadVertex(x - 1,  y));
                float3 upDir    = normalize(selfPt - LoadVertex(x,      y + 1));
                float3 downDir  = normalize(selfPt - LoadVertex(x,      y - 1));
                float3 rightDir = normalize(selfPt - LoadVertex(x + 1,  y));
    
                float3 luNorm = cross(leftDir, upDir);
                float3 ldNorm = cross(downDir, leftDir);
                float3 rdNorm = cross(rightDir, downDir);
                float3 ruNorm = cross(upDir, rightDir);
    
                float3 avgNorm = normalize(
                    luNorm * 0.25 + 
                    ldNorm * 0.25 + 
                    rdNorm * 0.25 + 
                    ruNorm * 0.25);
            
                StoreNormal(x, y, avgNorm);
            }
        }
    }

}


void ApplySmooth(uint3 id) {

    // Recalculate Normal
    {
        for (uint x = id.x * _MeshSection > 0 ? id.x * _MeshSection : 1; x < (id.x + 1) * _MeshSection && x < (_Size * 2); x++) {
    
            for (uint y = id.y * _MeshSection ? id.y * _MeshSection : 1; y <  (id.y + 1) * _MeshSection && y < (_Size * 2); y++) {
    
                float total = 0.0;
                for (int dx = -1; dx <= 1; dx++) 
                    for (int dy = -1; dy <= 1; dy++) 
                        total += LoadVertex(x + dx, y + dy).y;

                StoreVertexY(x, y, total * DIVIDE9);
            }
        }
    }

}

void ApplyConstraints(uint3 id) {

    // Apply Modifiers
    {
        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
    
                float3 vertex = LoadVertex(x, y);
                Modify modify = LoadModify(x, y);
                float base = LoadBase(x, y);
                
                if (modify.mask & MAXIMUM_BIT && base > modify.maximum)
                    base = modify.maximum;
                
                if (modify.mask & MINIMUM_BIT && base < modify.minimum)
                    base = modify.minimum;
    
                if (modify.mask & MANDATE_BIT)
                    base = modify.mandate;
            
                StoreVertexY(x, y, base);
            }
        }
    }

}

#ifdef DEFINE_OPERATION
// Modify Mesh Section
struct Operation {
    float2 position; // normalized
    float radius; // normalized
    float parameter; // arbitary
    uint type;
};

StructuredBuffer<Operation> _Operations;
int _Count; // operation _Count

void ApplyOperations(uint3 id) {
    
    // Execute Operations
    for (int o = 0; o < _Count; o++) {
        Operation operation = _Operations[o];

        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {

            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {

                float3 vertex = LoadVertex(x, y);
                float2 localPos = vertex.xz;

                float base = LoadBase(x, y);

                float distToCent = distance(operation.position, localPos);
                
                if (distToCent <= operation.radius) {
                    float proportion = 1.0 - distToCent / operation.radius;
                    
                    if (operation.type == 1) {
                        base += operation.parameter * proportion;
                    }
                    else if (operation.type == 2) {
                        base -= operation.parameter * proportion;
                    }
                    else if (operation.type == 3) {
                        base = (1.0 - proportion) * base + proportion * operation.parameter;
                    }
                    else if (operation.type == 4) {
                        float total = 0.0;
                        for (int dx = -1; dx <= 1; dx++) 
                            for (int dy = -1; dy <= 1; dy++) 
                                total += LoadVertex(x + dx, y + dy).y;

                        base = (1.0 - proportion) * base + proportion * total * DIVIDE9;
                    }
                }
                
                StoreVertexY(x, y, base);
                StoreBase(x, y, base);
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }
}

// this oeprate per vertex
[numthreads(32, 32, 1)]
void ModifyMesh(uint3 id : SV_DispatchThreadID) { 

    ApplyOperations(id);

    ApplyConstraints(id);

    ApplyNormals(id);
}
#endif

#ifdef DEFINE_APPLY
Texture2D<float4> _MandateRT; // 0-1, top down
Texture2D<float4> _MinimumRT; // 0-1, bottom up
Texture2D<float4> _MaximumRT; // 0-1, top down
float _Start; // +ve offset from 0.0, if bottom up, take the negative
float _Depth; // height of the _Depth texture space
float _Ignore; // 0-1, range greater to treat as nothing rendered

uint CalculateRTIndex(uint x, uint y) {
    return y * (_Size * 2 + 1) + x;
}

void ApplyRenderTexture(uint3 id) {
    
    // Apply Modifiers
    {
        float inverseIgnore = 1.0 - _Ignore;

        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
                
                uint2 index = uint2(x, y);
                uint2 mirrorIndex = uint2(x, _Size * 2 - y);

                float mandate;
                float minimum;
                float maximum;
                uint mask = 0;

                if (_MandateRT[index].r < _Ignore || _MandateRT[index].r > inverseIgnore)
                    mandate = 0.0;
                else {
                    mask |= MANDATE_BIT;
                    mandate = _MandateRT[index].r * _Depth - _Start;
                }

                if (_MinimumRT[index].r < _Ignore || _MandateRT[index].r > inverseIgnore)
                    minimum = 0.0;
                else {
                    mask |= MINIMUM_BIT;
                    minimum = _MinimumRT[index].r * _Depth - _Start;
                }

                if (_MaximumRT[mirrorIndex].r < _Ignore || _MandateRT[mirrorIndex].r > inverseIgnore)
                    maximum = 0.0;
                else {
                    mask |= MAXIMUM_BIT;
                    maximum = _Start - _MaximumRT[mirrorIndex].r * _Depth;
                }

                StoreModify(x, y, mandate, minimum, maximum, mask);
            }
        }
    }
}

// this oeprate per vertex
[numthreads(32, 32, 1)]
void ApplyModifiers(uint3 id: SV_DispatchThreadID) {

    ApplyRenderTexture(id);
    
    ApplyConstraints(id);

    ApplyNormals(id);
}
#endif

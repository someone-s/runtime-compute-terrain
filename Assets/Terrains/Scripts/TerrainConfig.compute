#pragma kernel ResetBuffers
#pragma kernel RestoreBuffers
#pragma kernel ExportBuffers

#include "TerrainCommon.hlsl"

uint CalculateLogicalIndex(uint x, uint y) {
    return y * (_Size + 1) + x;
}

// this oeprate per vertex
[numthreads(32, 32, 1)]
void ResetBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
    
                StoreModify(x, y, 0.0, 0.0, 0.0, 0);
                StoreBase(x, y, 0.0);
            }
        }
    }
}


struct Export {
    float height;
};
RWStructuredBuffer<Export> _Exports;

// this oeprate per vertex
[numthreads(32, 32, 1)]
void RestoreBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
                
                uint index = CalculateLogicalIndex(x, y);
                StoreVertexY(x, y, _Exports[index].height);
                StoreBase(x, y, _Exports[index].height);
            }
        }
    }
}

[numthreads(32, 32, 1)]
void ExportBuffers(uint3 id : SV_DispatchThreadID) {
    
    // Apply Modifiers
    {
        for (uint x = id.x * _MeshSection; x < (id.x + 1) * _MeshSection && x < (_Size * 2) + 1; x++) {
    
            for (uint y = id.y * _MeshSection; y <  (id.y + 1) * _MeshSection && y < (_Size * 2) + 1; y++) {
                
                uint index = CalculateLogicalIndex(x, y);
                _Exports[index].height = LoadBase(x, y);
            }
        }
    }
}
#pragma kernel Project
#pragma kernel Clear
#pragma kernel Convert

#define EPSILON 0.00000001

float _InvalidMin;
float _InvalidMax;

uint _Stride;
uint _PositionOffset;

float4x4 _LocalToWorld;
float4x4 _WorldToClip;
uint _NumTriangle;
ByteAddressBuffer _Vertices;
ByteAddressBuffer _Indices;

uint2 _Dimensions;
RWByteAddressBuffer _Depth;

uint _Mode; // 1 for Mandate, 2 for Minimum, 3 for Maximum

bool OutOfBounds(float3 vCS)
{
    return vCS.x < 0.0 || vCS.x > 1.0 || vCS.y < 0.0 || vCS.y > 1.0;
}

float4 MinMax(float3 aCS, float3 bCS, float3 cCS)
{
    float4 result;
    result.x = min(min(aCS.x, bCS.x), cCS.x);
    result.y = min(min(aCS.y, bCS.y), cCS.y);
    result.z = max(max(aCS.x, bCS.x), cCS.x);
    result.w = max(max(aCS.y, bCS.y), cCS.y);

    return result;
}

float3 BayCentric(float2 aCS, float2 bCS, float2 cCS, float2 pCS)
{
    float2 v0 = bCS - aCS;
    float2 v1 = cCS - aCS;
    float2 v2 = pCS - aCS;

    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;

    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;

    return float3(u, v, w);
}

uint EncodeFloatWithOrder(float value)
{
    uint uVal = asuint(value);
    uint mask = -int(uVal >> 31) | 0x80000000;
    return uVal ^ mask;
}

void DrawTriangle(uint3 id, float3 aCS, float3 bCS, float3 cCS)
{
    float4 boundCS = MinMax(aCS, bCS, cCS);
    float2 dimensionF = float2(_Dimensions);

    uint2 startPS = uint2(max(float2(0,0), boundCS.xy) * dimensionF);
    uint2 endPS = min(_Dimensions - uint2(1,1), uint2(boundCS.zw * dimensionF));

    for (uint x = startPS.x; x <= endPS.x; x++)
    {
        for (uint y = startPS.y; y <= endPS.y; y++) 
        {
            float3 bc = BayCentric(aCS.xy, bCS.xy, cCS.xy, (float2(x, y) + float2(0.5, 0.5)) / dimensionF);
            if (bc.x < 0.0 || bc.y < 0.0 || bc.z < 0.0) continue;

            float depth = bc.x * aCS.z + bc.y * bCS.z + bc.z * cCS.z;
            uint encode = EncodeFloatWithOrder(depth);
            uint base = (y * _Dimensions.x + x) * 3;
            
            switch (_Mode)
            {
                case 1: // Mandate
                    _Depth.InterlockedMin((base + 0) * 4, encode);
                    break;
                case 2: // Minimum
                    _Depth.InterlockedMin((base + 1) * 4, encode);
                    break;
                case 3: // Maximum
                    _Depth.InterlockedMax((base + 2) * 4, encode);
                    break;
            }
        }
    }

}

[numthreads(512,1,1)]
void Project(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumTriangle) return;

    float3 aOS = asfloat(_Vertices.Load3(_Indices.Load((id.x * 3 + 0) * 4) * _Stride + _PositionOffset));
    float3 bOS = asfloat(_Vertices.Load3(_Indices.Load((id.x * 3 + 1) * 4) * _Stride + _PositionOffset));
    float3 cOS = asfloat(_Vertices.Load3(_Indices.Load((id.x * 3 + 2) * 4) * _Stride + _PositionOffset));

    float3 aWS = mul(_LocalToWorld, float4(aOS, 1)).xyz;
    float3 bWS = mul(_LocalToWorld, float4(bOS, 1)).xyz;
    float3 cWS = mul(_LocalToWorld, float4(cOS, 1)).xyz;

    float3 aCS = mul(_WorldToClip, float4(aWS, 1)).xyz;
    float3 bCS = mul(_WorldToClip, float4(bWS, 1)).xyz;
    float3 cCS = mul(_WorldToClip, float4(cWS, 1)).xyz;

    // detect out of bounds triangle
    if (OutOfBounds(aCS) && OutOfBounds(bCS) && OutOfBounds(cCS)) return;

    // detect collapsed triangle
    if (distance(aCS.xy, bCS.xy) < EPSILON || distance(bCS.xy, cCS.xy) < EPSILON || distance(cCS.xy, aCS.xy) < EPSILON) return;
    
    DrawTriangle(id, aCS, bCS, cCS);
}

[numthreads(32,32,1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Dimensions.x || id.y >= _Dimensions.x) return;

    uint base = (id.y * _Dimensions.x + id.x) * 3;

    _Depth.Store((base + 0) * 4, EncodeFloatWithOrder(_InvalidMax));
    _Depth.Store((base + 1) * 4, EncodeFloatWithOrder(_InvalidMax));
    _Depth.Store((base + 2) * 4, EncodeFloatWithOrder(_InvalidMin));
}

float DecodeFloatWithOrder(uint value)
{
    uint mask = ((value >> 31) - 1) | 0x80000000;
    return asfloat(value ^ mask);
}

[numthreads(32,32,1)]
void Convert(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Dimensions.x || id.y >= _Dimensions.y) return;

    uint base = (id.y * _Dimensions.x + id.x) * 3;
    
    _Depth.Store((base + 0) * 4, asuint(DecodeFloatWithOrder(_Depth.Load((base + 0) * 4))));
    _Depth.Store((base + 1) * 4, asuint(DecodeFloatWithOrder(_Depth.Load((base + 1) * 4))));
    _Depth.Store((base + 2) * 4, asuint(DecodeFloatWithOrder(_Depth.Load((base + 2) * 4))));
}
#pragma kernel ApplyModifiers DEFINE_APPLY
#pragma kernel ModifyMesh DEFINE_OPERATION

#define MANDATE_BIT 1
#define MINIMUM_BIT 2
#define MAXIMUM_BIT 4
#define EPSILON 0.00000001
#define DIVIDE9 0.11111111
#define FLOAT_SIZE_IN_BYTES 4

struct Modify {
    float terrain;
    float mandate;
    float minimum;
    float maximum;
    uint mask;
};

RWByteAddressBuffer verticesTL;
RWStructuredBuffer<Modify> modifyTL;

RWByteAddressBuffer verticesTR;
RWStructuredBuffer<Modify> modifyTR;

RWByteAddressBuffer verticesBL;
RWStructuredBuffer<Modify> modifyBL;

RWByteAddressBuffer verticesBR;
RWStructuredBuffer<Modify> modifyBR;

int stride;
int positionOffset;
int normalOffset;

uint size; // i.e. 1000
uint meshSection; // if size is 1000, meshSection is 126 ceil((1000 * 2 + 1) / 32)

uint CalculateVertexIndex(uint x, uint y) {
    return (y * (size + 1) + x) * stride + positionOffset;
}
float3 LoadVertex(uint x, uint y) {
    if (x > size && y > size) {
        float3 value = asfloat(verticesTR.Load3(CalculateVertexIndex(x - size, y - size)));
        value.x += 1.0;
        value.z += 1.0;
        return value;
    }
    else if (x > size) {
        float3 value = asfloat(verticesBR.Load3(CalculateVertexIndex(x - size, y)));
        value.x += 1.0;
        return value;
    }
    else if (y > size) {
        float3 value = asfloat(verticesTL.Load3(CalculateVertexIndex(x, y - size)));
        value.z += 1.0;
        return value;
    }
    else {
        float3 value = asfloat(verticesBL.Load3(CalculateVertexIndex(x, y)));
        return value;
    }
}
void StoreVertex(uint x, uint y, float3 value) {
    if (x >= size && y >= size) {
        float3 valueCopy = value;
        valueCopy.x -= 1.0;
        valueCopy.z -= 1.0;
        verticesTR.Store3(CalculateVertexIndex(x - size, y - size), asuint(valueCopy));
    }

    if (x >= size && y <= size) {
        float3 valueCopy = value;
        valueCopy.x -= 1.0;
        verticesBR.Store3(CalculateVertexIndex(x - size, y), asuint(valueCopy));
    }

    if (x <= size && y >= size) {
        float3 valueCopy = value;
        valueCopy.z -= 1.0;
        verticesTL.Store3(CalculateVertexIndex(x, y - size), asuint(valueCopy));
    }

    if (x <= size && y <= size) {
        float3 valueCopy = value;
        verticesBL.Store3(CalculateVertexIndex(x, y), asuint(valueCopy));
    }
}
void StoreVertexY(uint x, uint y, float value) {
    if (x >= size && y >= size) 
        verticesTR.Store(CalculateVertexIndex(x - size, y - size) + FLOAT_SIZE_IN_BYTES, asuint(value));

    if (x >= size && y <= size) 
        verticesBR.Store(CalculateVertexIndex(x - size, y) + FLOAT_SIZE_IN_BYTES, asuint(value));

    if (x <= size && y >= size) 
        verticesTL.Store(CalculateVertexIndex(x, y - size) + FLOAT_SIZE_IN_BYTES, asuint(value));

    if (x <= size && y <= size) 
        verticesBL.Store(CalculateVertexIndex(x, y) + FLOAT_SIZE_IN_BYTES, asuint(value));
}

uint CalculateNormalIndex(uint x, uint y) {
    return (y * (size + 1) + x) * stride + normalOffset;
}
void StoreNormal(uint x, uint y, float3 value) {
    if (x >= size && y >= size)
        verticesTR.Store3(CalculateNormalIndex(x - size, y - size), asuint(value));

    if (x >= size && y <= size)
        verticesBR.Store3(CalculateNormalIndex(x - size, y), asuint(value));

    if (x <= size && y >= size)
        verticesTL.Store3(CalculateNormalIndex(x, y - size), asuint(value));

    if (x <= size && y <= size)
        verticesBL.Store3(CalculateNormalIndex(x, y), asuint(value));
}

uint CalculateModifyIndex(uint x, uint y) {
    return y * (size + 1) + x;
}
Modify LoadModify(uint x, uint y) {
    if (x > size && y > size)
        return modifyTR[CalculateModifyIndex(x - size, y - size)];
    else if (x > size) 
        return modifyBR[CalculateModifyIndex(x - size, y       )];
    else if (y > size) 
        return modifyTL[CalculateModifyIndex(x,        y - size)];
    else 
        return modifyBL[CalculateModifyIndex(x,        y       )];
}
void StoreModify(uint x, uint y, float mandate, float minimum, float maximum, uint mask) {

    if (x >= size && y >= size) {
        uint index = CalculateModifyIndex(x - size, y - size);
        modifyTR[index].mandate = mandate;
        modifyTR[index].minimum = minimum;
        modifyTR[index].maximum = maximum;
        modifyTR[index].mask = mask;
    }

    if (x >= size && y <= size) {
        uint index = CalculateModifyIndex(x - size, y);
        modifyBR[index].mandate = mandate;
        modifyBR[index].minimum = minimum;
        modifyBR[index].maximum = maximum;
        modifyBR[index].mask = mask;
    }

    if (x <= size && y >= size) {
        uint index = CalculateModifyIndex(x, y - size);
        modifyTL[index].mandate = mandate;
        modifyTL[index].minimum = minimum;
        modifyTL[index].maximum = maximum;
        modifyTL[index].mask = mask;
    }

    if (x <= size && y <= size) {
        uint index = CalculateModifyIndex(x, y);
        modifyBL[index].mandate = mandate;
        modifyBL[index].minimum = minimum;
        modifyBL[index].maximum = maximum;
        modifyBL[index].mask = mask;
    }
}
void StoreBase(uint x, uint y, float value) {
    if (x >= size && y >= size) {
        uint index = CalculateModifyIndex(x - size, y - size);
        modifyTR[index].terrain = value;
    }

    if (x >= size && y <= size) {
        uint index = CalculateModifyIndex(x - size, y);
        modifyBR[index].terrain = value;
    }

    if (x <= size && y >= size) {
        uint index = CalculateModifyIndex(x, y - size);
        modifyTL[index].terrain = value;
    }

    if (x <= size && y <= size) {
        uint index = CalculateModifyIndex(x, y);
        modifyBL[index].terrain = value;
    }
}


void ApplyNormals(uint3 id) {

    // Recalculate Normal
    {
        for (uint x = id.x * meshSection > 0 ? id.x * meshSection : 1; x < (id.x + 1) * meshSection && x < (size * 2); x++) {
    
            for (uint y = id.y * meshSection ? id.y * meshSection : 1; y <  (id.y + 1) * meshSection && y < (size * 2); y++) {
    
                float3 vertex = LoadVertex(x, y);
    
                float3 selfPt   = LoadVertex(x, y);
                float3 leftDir  = normalize(selfPt - LoadVertex(x - 1,  y));
                float3 upDir    = normalize(selfPt - LoadVertex(x,      y + 1));
                float3 downDir  = normalize(selfPt - LoadVertex(x,      y - 1));
                float3 rightDir = normalize(selfPt - LoadVertex(x + 1,  y));
    
                float3 luNorm = cross(leftDir, upDir);
                float3 ldNorm = cross(downDir, leftDir);
                float3 rdNorm = cross(rightDir, downDir);
                float3 ruNorm = cross(upDir, rightDir);
    
                float3 avgNorm = normalize(
                    luNorm * 0.25 + 
                    ldNorm * 0.25 + 
                    rdNorm * 0.25 + 
                    ruNorm * 0.25);
            
                StoreNormal(x, y, avgNorm);
            }
        }
    }

}

void ApplyConstraints(uint3 id) {

    // Apply Modifiers
    {
        for (uint x = id.x * meshSection; x < (id.x + 1) * meshSection && x < (size * 2) + 1; x++) {
    
            for (uint y = id.y * meshSection; y <  (id.y + 1) * meshSection && y < (size * 2) + 1; y++) {
    
                float3 vertex = LoadVertex(x, y);
                Modify modify = LoadModify(x, y);
                float base = modify.terrain;
                
                if (modify.mask & MAXIMUM_BIT && base > modify.maximum)
                    base = modify.maximum;
                
                if (modify.mask & MINIMUM_BIT && base < modify.minimum)
                    base = modify.minimum;
    
                if (modify.mask & MANDATE_BIT)
                    base = modify.mandate;
            
                StoreVertexY(x, y, base);
            }
        }
    }

}

#ifdef DEFINE_OPERATION
// Modify Mesh Section
struct Operation {
    float2 position; // normalized
    float radius; // normalized
    float parameter; // arbitary
    uint type;
};

StructuredBuffer<Operation> operations;
int count; // operation count

void ApplyOperations(uint3 id) {
    
    // Execute Operations
    for (int o = 0; o < count; o++) {
        Operation operation = operations[o];

        for (uint x = id.x * meshSection; x < (id.x + 1) * meshSection && x < (size * 2) + 1; x++) {

            for (uint y = id.y * meshSection; y <  (id.y + 1) * meshSection && y < (size * 2) + 1; y++) {

                float3 vertex = LoadVertex(x, y);
                float2 localPos = vertex.xz;

                float base = LoadModify(x, y).terrain;

                float distToCent = distance(operation.position, localPos);
                
                if (distToCent <= operation.radius) {
                    float proportion = 1.0 - distToCent / operation.radius;
                    
                    if (operation.type == 1) {
                        base += operation.parameter * proportion;
                    }
                    else if (operation.type == 2) {
                        base -= operation.parameter * proportion;
                    }
                    else if (operation.type == 3) {
                        base = (1.0 - proportion) * base + proportion * operation.parameter;
                    }
                    else if (operation.type == 4) {
                        float average = 0.0;
                        for (int dx = -1; dx <= 1; dx++) 
                            for (int dy = -1; dy <= 1; dy++) 
                                average += LoadVertex(x + dx, y + dy).y * DIVIDE9;

                        base = (1.0 - proportion) * base + proportion * average;
                    }
                }
                
                StoreVertexY(x, y, base);
                StoreBase(x, y, base);
            }
        }

        GroupMemoryBarrierWithGroupSync();
    }
}

// this oeprate per vertex
[numthreads(32, 32, 1)]
void ModifyMesh(uint3 id : SV_DispatchThreadID) { 

    ApplyOperations(id);

    ApplyConstraints(id);

    ApplyNormals(id);
}
#endif

#ifdef DEFINE_APPLY
Texture2D<float4> mandateRT; // 0-1, top down
Texture2D<float4> minimumRT; // 0-1, bottom up
Texture2D<float4> maximumRT; // 0-1, top down
float start; // +ve offset from 0.0, if bottom up, take the negative
float depth; // height of the depth texture space
float ignore; // 0-1, range greater to treat as nothing rendered

uint CalculateRTIndex(uint x, uint y) {
    return y * (size * 2 + 1) + x;
}

void ApplyRenderTexture(uint3 id) {
    
    // Apply Modifiers
    {
        float inverseIgnore = 1.0 - ignore;

        for (uint x = id.x * meshSection; x < (id.x + 1) * meshSection && x < (size * 2) + 1; x++) {
    
            for (uint y = id.y * meshSection; y <  (id.y + 1) * meshSection && y < (size * 2) + 1; y++) {
                
                uint2 index = uint2(x, y);
                uint2 mirrorIndex = uint2(x, size * 2 - y);

                float mandate;
                float minimum;
                float maximum;
                uint mask = 0;

                if (mandateRT[index].r < ignore || mandateRT[index].r > inverseIgnore)
                    mandate = 0.0;
                else {
                    mask |= MANDATE_BIT;
                    mandate = mandateRT[index].r * depth - start;
                }

                if (minimumRT[index].r < ignore || mandateRT[index].r > inverseIgnore)
                    minimum = 0.0;
                else {
                    mask |= MINIMUM_BIT;
                    minimum = minimumRT[index].r * depth - start;
                }

                if (maximumRT[mirrorIndex].r < ignore || mandateRT[mirrorIndex].r > inverseIgnore)
                    maximum = 0.0;
                else {
                    mask |= MAXIMUM_BIT;
                    maximum = start - maximumRT[mirrorIndex].r * depth;
                }

                StoreModify(x, y, mandate, minimum, maximum, mask);
            }
        }
    }
}

// this oeprate per vertex
[numthreads(32, 32, 1)]
void ApplyModifiers(uint3 id: SV_DispatchThreadID) {

    ApplyRenderTexture(id);
    
    ApplyConstraints(id);

    ApplyNormals(id);
}
#endif

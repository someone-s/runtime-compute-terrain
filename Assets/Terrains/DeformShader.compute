#pragma kernel ModifyMesh
#pragma kernel RecalculateNormal

RWByteAddressBuffer vertices;
int stride;
int positionOffset;
int normalOffset;

uint size; // i.e. 1000
uint meshSection; // if size is 1000, meshSection is 32 ceil((1000 + 1 + 2) / 32)
uint normalSection; // if size is 1000, normalSection is 32 ceil(1000 + 1 / 32)

struct Operation {
    float2 position; // normalized
    float radius; // normalized
    float parameter; // arbitary
    uint type;
};

StructuredBuffer<Operation> operations;
int count; // operation count

uint CalculateTrueVertexIndex(int x, int y) {
    return (y * (size + 1 + 2) + x) * stride + positionOffset;
}

uint CalculatePaddedVertexIndex(int x, int y) {
    return ((y + 1) * (size + 1 + 2) + (x + 1)) * stride + positionOffset;
}

uint CalculatePaddedNormalIndex(int x, int y) {
    return ((y + 1) * (size + 1 + 2) + (x + 1)) * stride + normalOffset;
}

// this oeprate per vertex
[numthreads(32, 32, 1)]
void ModifyMesh(uint3 id : SV_DispatchThreadID) {

    for (uint x = id.x * meshSection; x < (id.x + 1) * meshSection; x++) {

        // ignore out of bounds
        if (x >= size + 1 + 2)
            continue;

        for (uint y = id.y * meshSection; y <  (id.y + 1) * meshSection; y++) {

            // ignore out of bounds
            if (y >= size + 1 + 2)
                continue;

            uint index = CalculateTrueVertexIndex(x, y);
            float3 vertex = asfloat(vertices.Load3(index));

            float2 localPos = vertex.xz;
            for (int o = 0; o < count; o++) {
                Operation operation = operations[o];
                float distToCent = distance(operation.position, localPos);
                
                if (distToCent <= operation.radius) {
                    float proportion = 1.0 - distToCent / operation.radius;
                    
                    if (operation.type == 1) {
                        vertex.y += operation.parameter * proportion;
                    }
                    else if (operation.type == 2) {
                        vertex.y -= operation.parameter * proportion;
                    }
                    else if (operation.type == 3) {
                        vertex.y = (1.0 - proportion) * vertex.y + proportion * operation.parameter;
                    }
                }   
            }
            
            vertices.Store3(index, asuint(vertex));
        }
    }
}

// this operate per inner vertex
[numthreads(32, 32, 1)]
void RecalculateNormal(uint3 id : SV_DispatchThreadID) {
    
    for (uint x = id.x * normalSection; x < (id.x + 1) * normalSection; x++) {

        // ignore edge and out of bounds
        if (x > size)
            continue;

        for (uint y = id.y * normalSection; y < (id.y + 1) * normalSection; y++) {

            // ignore edge and out of bounds
            if (y > size)
                continue;

            float3 selfPt   = asfloat(vertices.Load3(CalculatePaddedVertexIndex(x, y)));
            float3 leftDir  = normalize(selfPt - asfloat(vertices.Load3(CalculatePaddedVertexIndex(x - 1,  y))));
            float3 upDir    = normalize(selfPt - asfloat(vertices.Load3(CalculatePaddedVertexIndex(x,      y + 1))));
            float3 downDir  = normalize(selfPt - asfloat(vertices.Load3(CalculatePaddedVertexIndex(x,      y - 1))));
            float3 rightDir = normalize(selfPt - asfloat(vertices.Load3(CalculatePaddedVertexIndex(x + 1,  y))));

            float3 luNorm = cross(leftDir, upDir);
            float3 ldNorm = cross(downDir, leftDir);
            float3 rdNorm = cross(rightDir, downDir);
            float3 ruNorm = cross(upDir, rightDir);

            float3 avgNorm = normalize(
                luNorm * 0.25 + 
                ldNorm * 0.25 + 
                rdNorm * 0.25 + 
                ruNorm * 0.25);

            vertices.Store3(CalculatePaddedNormalIndex(x, y), asuint(avgNorm));
        }
    }
}

// this opearte per square
[numthreads(32, 32, 1)]
void Intersect(uint3 id : SV_DispatchThreadID) {

    int2 base = int2(id.xy) * meshSection;

    for (uint x = 0; x < meshSection; x++) {

        // ignore out of bounds
        if (base.x + x > size)
            continue;

        for (uint y = 0; y < meshSection; y++) {

            // ignore out of bounds
            if (base.y + y > size)
                continue;

            
        }
    }
}
#pragma kernel Scatter

uint _Skip;
uint _Multiplier;

ByteAddressBuffer _TerrainVertices;
ByteAddressBuffer _TerrainTriangles;
uint _TerrainTriangleCount;
int _TerrainStride;
int _TerrainPositionOffset;
int _TerrainNormalOffset;

float3 _Anchor;
float _Area;

RWStructuredBuffer<float4x4> _TransformMatrices;

float3 LoadTerrainPosition(uint index) {
    return asfloat(_TerrainVertices.Load3(index * _TerrainStride + _TerrainPositionOffset));
}
float3 LoadTerrainNormal(uint index) {
    return asfloat(_TerrainVertices.Load3(index * _TerrainStride + _TerrainNormalOffset));
}
// assume 32bit indices
int LoadTerrainTriangle(uint index) {
    return asint(_TerrainTriangles.Load(index * 4));
}

float _Scale;
float _MinHeight;
float _MaxHeight;
float _MinOffset;
float _MaxOffset;
float4x4 _TerrainObjectToWorld;

#define ONE_OVER_PI 0.31830988618
#define TWO_PI 6.28318530718

float randomRange(float2 seed, float min, float max)
{
    float random = frac(sin(dot(seed, float2(12.9898, 78.233)))*43758.5453);
    return lerp(min, max, random);
}

float4x4 rotationMatrixY(float angle)
{
    float s, c;
    sincos(angle, s, c);

    return float4x4
    (
        c,   0.0, s,   0.0,
        0.0, 1.0, 0.0, 0.0,
        -s,  0.0, c,   0.0,
        0.0, 0.0, 0.0, 1.0
    );
}

[numthreads(64, 1, 1)]
void Scatter(uint3 id : SV_DispatchThreadID)
{
    uint triangleIndex = id.x * _Skip;

    if (triangleIndex > _TerrainTriangleCount)
        return;

    int triangleStart = triangleIndex * 3;

    float3 position0 = LoadTerrainPosition(LoadTerrainTriangle(triangleStart));
    float3 position1 = LoadTerrainPosition(LoadTerrainTriangle(triangleStart + 1));
    float3 position2 = LoadTerrainPosition(LoadTerrainTriangle(triangleStart + 2));
    
    float3 triangleCenterPos = (position0 + position1 + position2) / 3.0;
    triangleCenterPos += _Anchor;

    float2 seed = float2(id.x * _Multiplier, 1.0);

    for (uint index = id.x * _Multiplier; index < (id.x + 1) * _Multiplier; index++)
    {   
        //float r1 = randomRange(seed, _MinHeight, _MaxHeight);
        //seed.y = r1;
        //float _ScaleY = _Scale * r1;
    
        float r2 = randomRange(seed, _MinOffset, _MaxOffset);
        seed.x = r2;
        float offsetX = r2;

        float r3 = randomRange(seed, _MinOffset, _MaxOffset);
        seed.y = r3;
        float offsetZ = r3;
    
        float4x4 grassTransformMatrix = float4x4
        (
            _Scale, 0.0,    0.0,   triangleCenterPos.x + offsetX,
            0.0,   _Scale, 0.0,   triangleCenterPos.y,
            0.0,   0.0,    _Scale, triangleCenterPos.z + offsetZ,
            0.0,   0.0,    0.0,   1.0
        );
    
        float r4 = randomRange(seed, 0.0, TWO_PI);
        seed.x = r4;
        float4x4 randomRotationMatrix = rotationMatrixY(r4);
    
        _TransformMatrices[index] = mul(grassTransformMatrix, randomRotationMatrix);
    }
}
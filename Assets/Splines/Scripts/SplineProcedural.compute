#pragma kernel UpdateTrack

#define EPSILON (0.00000001)
#define DIVIDE9 (0.11111111)

#define THREAD_COUNT 64

ByteAddressBuffer _SourceVertices;
RWByteAddressBuffer _DestVertices;


uint _MaxPoint;
uint _BaseVertex;
uint _SliceSize; // Number of _Points per slice

int _Stride;
int _PositionOffset;
int _NormalOffset;
int _UVOffset;

float3 _P0;
float3 _P1;
float3 _P2;
float3 _P3;

float3 _US;
float3 _UE;

uint _Vertical;

float _UVStretch;

float3 EvaluatePosition(float t)
{
    float tSquare = t * t;
    float tCube =  tSquare * t;

    return 
        _P0 * (-1.0 * tCube + 3.0 * tSquare - 3.0 * t + 1.0)
      + _P1 * ( 3.0 * tCube - 6.0 * tSquare + 3.0 * t)
      + _P2 * (-3.0 * tCube + 3.0 * tSquare)
      + _P3 * (       tCube);
}

float3 EvaluateTangent(float t)
{
    float tSquare = t * t;

    return normalize(
        _P0 * (-3.0 * tSquare +  6.0 * t - 3.0)
      + _P1 * ( 9.0 * tSquare - 12.0 * t + 3.0)
      + _P2 * (-9.0 * tSquare +  6.0 * t)
      + _P3 * ( 3.0 * tSquare));
}

float3 EvaluateUp(float p)
{
    float product = clamp(dot(_US, _UE), -1.0, 1.0);

    float theta = acos(product) * p;
    
    float3 relative = _UE - _US * product;
    if (length(relative) != 0.0)
        relative = normalize(relative);

    return _US * cos(theta) + relative * sin(theta);
}

void StepT(float curveLength, float travelDistance, inout float3 beginPoint, inout float t, inout float traversedDistance)
{
    float remainingDistance = travelDistance;
    float3 testPoint = beginPoint;

    while (remainingDistance > 0.001)
    {
        traversedDistance += remainingDistance;
        t = traversedDistance / curveLength;

        if (t > 1.0)
        {
            traversedDistance = curveLength;
            t = 1.0;
            return;
        }
        else if (t < 0.0)
        {
            traversedDistance = 0.0;
            t = 0.0;
            return;
        }

        testPoint = EvaluatePosition(t);
        float dist = distance(beginPoint, testPoint);
        remainingDistance = travelDistance - dist;
    }

    beginPoint = testPoint;
}

void GetT(float curveLength, uint pointIndex, float startOffset, float segmentLength, out float t, out float traversedDistance)
{
    if (pointIndex * segmentLength >= curveLength)
    {
        t = 1.0;
        traversedDistance = curveLength;
        return;
    }
    else
    {
        t = 0.0;
        traversedDistance = 0.0;
    }

    float3 beginPoint = _P0;
    StepT(curveLength, startOffset, beginPoint, t, traversedDistance);

    for (uint i = 1; i <= pointIndex; i++)
        StepT(curveLength, segmentLength, beginPoint, t, traversedDistance);
}

void GetPoint(float curveLength, float pointIndex, float startOffset, float segmentLength, out float3 position, out float3 tangent, out float3 up)
{
    float t, traversedDistance;
    GetT(curveLength, pointIndex, startOffset, segmentLength, t, traversedDistance);

    position = EvaluatePosition(t);
    tangent = EvaluateTangent(t);
    up = EvaluateUp(traversedDistance / curveLength);
}

float4x4 LookRotation(float3 tangent, float3 up)
{
    float3 right = normalize(cross(tangent, up));
    float3 adjustedUp = normalize(cross(right, tangent));

    return float4x4(
        right.x, adjustedUp.x, tangent.x, 0.0,
        right.y, adjustedUp.y, tangent.y, 0.0,
        right.z, adjustedUp.z, tangent.z, 0.0,
        0.0,     0.0,           0.0,      1.0
    );
}

float4x4 Translate(float3 position)
{
    return float4x4(
        1.0, 0.0, 0.0, position.x,
        0.0, 1.0, 0.0, position.y,
        0.0, 0.0, 1.0, position.z,
        0.0, 0.0, 0.0, 1.0
    );
}

float _ApproxLength;
float _StartOffset;
float _ActualSpacing;
uint _PointCount;
uint _PointPerThread;

[numthreads(THREAD_COUNT, 1, 1)]
void UpdateTrack(uint3 id : SV_DispatchThreadID)
{
    for (uint p = id.x * _PointPerThread; p < (id.x + 1) * _PointPerThread && p < _PointCount; p++)
    {
        float3 position, tangent, up;
        GetPoint(_ApproxLength, p, _StartOffset, _ActualSpacing, position, tangent, up);

        if (_Vertical == 1)
        {
            tangent.y = 0.0;
            tangent = normalize(tangent);
        }

        float4x4 rotation = LookRotation(tangent, up);
        float4x4 translation = Translate(position);

        float4x4 transform = mul(translation, rotation);

        for (uint i = 0; i < _SliceSize; i++) {
            uint locationStart = (_BaseVertex + p * _SliceSize + i) * _Stride;

            uint posLocation     = locationStart + _PositionOffset;
            float3 sourcePos     = asfloat(_SourceVertices.Load3(posLocation));
            float3 translatedPos = mul(transform, float4(sourcePos, 1)).xyz;
            _DestVertices.Store3(posLocation, asuint(translatedPos));

            uint normLocation  = locationStart + _NormalOffset;
            float3 sourceNorm  = asfloat(_SourceVertices.Load3(normLocation));
            float3 rotatedNorm = mul(transform, float4(sourceNorm, 0)).xyz;
            _DestVertices.Store3(normLocation, asuint(rotatedNorm));

            uint uvLocation = locationStart + _UVOffset;
            float2 sourceUV  = asfloat(_SourceVertices.Load2(uvLocation));
            sourceUV.x += _ActualSpacing * p * _UVStretch;
            _DestVertices.Store2(uvLocation, asuint(sourceUV));
        }
    }
}
